/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  ad_converter                           */
/*      FILE         :  ad_converter.c                         */
/*      DESCRIPTION  :  Main Program                           */
/*                                                             */
/*      This file was generated by e2 studio.                  */
/*                                                             */
/***************************************************************/

#include <iodefine.h>
#include "ad_converter.h"
#ifdef CPPAPP
//Initialize global constructors
extern void __main()
{
  static int initialized;
  if (! initialized)
    {
      typedef void (*pfunc) ();
      extern pfunc __ctors[];
      extern pfunc __ctors_end[];
      pfunc *p;

      initialized = 1;
      for (p = __ctors_end; p > __ctors; )
    (*--p) ();

    }
}
#endif 

int main(void) {
	main_clock_initialize();
	ad_converter_initialize();
	SCI_init(115200);
	CMT0_initialize();
    while(1) {

	// TODO: add application code here
    }
return 0;
}
void main_clock_initialize(void) {

	//PLL(Phase Locked Loop:発振器からの周波数を逓倍)の動作周波数はMAX:200MHz
	//動作周期は100MHz
	/* PLL回路 20逓倍× 入力1分周 (10.000MHz * 20 = 200MHz)
	 * 0b00 010011 000000 00 = 0x1300*/
	SYSTEM.PRCR.WORD = 0xa501; /*クロックソース選択の保護の解除*/
	SYSTEM.PLLCR.WORD = 0x1300;
	SYSTEM.PLLCR2.BIT.PLLEN = 0; /*PLL ENABLE */

	/* BCLK端子出力1/4(MAX:50MHz)(BCLKとBCLK端子出力は別)0010b
	 * PCLKB1/4(MAX:50MHz)0010b
	 * PCLKA=ICLK1/2(MAX:100MHz)0001b
	 * SDCLK停止 1
	 * BCLK停止 1
	 * ICK1/2(MAX:100MHz) 0001b
	 * FCK1/4(MAX:50MHz) 0010b
	 * 0b 0010 0001 1 1 00 0001 0010 0010 0001 0001 = 0x21C12211 */
	SYSTEM.SCKCR.LONG = 0x21C12211;

	/* IEBCK1/4(MAX:50MHz)0010b
	 * UCLK1/4(使わない場合0001b)
	 * 00000000 0001 0010b = 0x0012  */
	SYSTEM.SCKCR2.WORD = 0x0012;

	/*BCLK = (1/2) * PLL(MAX:100MHz) */
	SYSTEM.BCKCR.BYTE = 0x01;

	/* クロックソース選択：PLL回路選択100
	 * 00000 100 00000000b = 0x0400*/
	SYSTEM.SCKCR3.WORD = 0x0400;

	SYSTEM.PRCR.WORD = 0xa500; /*クロックソース選択の保護*/
}

void ad_converter_initialize(void) {

	SYSTEM.PRCR.WORD = 0xA502;      // Release Protect
	MSTP(S12AD) = 0;                // Wake up S12AD
	SYSTEM.PRCR.WORD = 0xA500;      // Protect

	//Set PDR
	PORTE.PDR.BIT.B3 = 0;           // Set PE3: Input

	// Set MPC
	PORTE.PMR.BIT.B3 = 1;           // Set PE3: Peripheral

	MPC.PWPR.BIT.B0WI = 0;          // Release protect
	MPC.PWPR.BIT.PFSWE = 1;
	MPC.PE3PFS.BIT.ASEL = 1;        // Set PE3: Analog Input
	MPC.PWPR.BIT.PFSWE = 0;         // Protect
	MPC.PWPR.BIT.B0WI = 1;

	// S12AD Settings software trigger
	S12AD.ADCSR.BIT.CKS = 3;        //
	S12AD.ADCSR.BIT.ADCS = 0;       // Single scanning
	S12AD.ADANS0.WORD = 0x0000;     // S12ADC: no
	S12AD.ADADS0.WORD = 0x0000;     // Disable ADD result Mode
	S12AD.ADCER.BIT.ACE = 1;        // Auto clearing
	S12AD.ADCER.BIT.ADRFMT = 0;     // Right -justified
	S12AD.ADSSTR01.BIT.SST1 = 20;    // 800us

}
void ad_print(void) {
	S12AD.ADANS0.BIT.ANS0 = 0x800;
	//AD変換開始
	S12AD.ADCSR.BIT.ADST = 1;
	while ( S12AD.ADCSR.BIT.ADST == 1)
		;

	int ad = S12AD.ADDR11;
	int ad_mv = ((float) (ad) * 0.80586081F);
	SCI_print("AD: ");
	SCI_val_println(ad_mv);
}
void SCI_init(unsigned long bps) {
	int PCLK = 50;

	// Set MPC
	PORT2.PMR.BIT.B6 = 1;           // P26: peripheral
	PORT3.PMR.BIT.B0 = 1;           // P30: peripheral

	MPC.PWPR.BIT.B0WI = 0;          // Release protect
	MPC.PWPR.BIT.PFSWE = 1;
	MPC.P26PFS.BIT.PSEL = 0x0A;     // Set P26: TXD1
	MPC.P30PFS.BIT.PSEL = 0x0A;     // Set P30: RXD1
	MPC.PWPR.BIT.PFSWE = 0;         // Protect
	MPC.PWPR.BIT.B0WI = 1;

	unsigned char smr;
	unsigned char brr;
	int i;

	// RX FIFO
	rx_fifo.index_read = 0;
	rx_fifo.index_write = 0;

	// TX FIFO
	tx_fifo.index_read = 0;
	tx_fifo.index_write = 0;

	// Serial Mode Register
	smr = 0;

	// Bit Rate Register
	brr = (PCLK * 1000 * 1000 / (32 * bps)) - 1;

	SYSTEM.PRCR.WORD = 0xA502;
	MSTP(SCI1) = 0;
	SYSTEM.PRCR.WORD = 0xA500;

	SCI1.SCR.BYTE = 0x00;
	SCI1.SMR.BYTE = smr;
	SCI1.BRR = brr;

	for (i = 0; i < bps + 100; i++)
		;

	IEN(SCI1, TXI1)= 1;
	IEN(SCI1, RXI1)= 1;
	IEN(SCI1, TEI1)= 1;
	//  IEN(SCI1, ERI1)= 1;

	IPR(SCI1,)= 1; //割り込みレベ10

	SCI1.SCR.BIT.RE = 1;	//シリアル受信動作を許可
	SCI1.SCR.BIT.TE = 1;	//シリアル送信動作を許可
	SCI1.SCR.BIT.RIE = 1;	//RXI割り込み（正常にデータが受信でき差にに呼び出される）の許可

}

void SCI_single_char_transport_TDR(unsigned char input_data) {
	tx_fifo.buffer[tx_fifo.index_write] = input_data;	//データを送信バッファに追加
	tx_fifo.index_write++;
	if (tx_fifo.index_write >= BUFFER_SIZE) {	//配列の末尾にいる場合indexは0へ
		tx_fifo.index_write = 0;
	}
	if ((tx_fifo.index_write) != tx_fifo.index_read) {	//未送信データがバッファにある場合
		if (SCI1.SCR.BIT.TIE != 1) {
			SCI_put_data_on_TDR();	//データをTDRレジスタに書き込み
		}
	}

}

void SCI_put_data_on_TDR(void) {
	unsigned char data = tx_fifo.buffer[tx_fifo.index_read];
	tx_fifo.index_read++;

	if ((tx_fifo.index_read) >= BUFFER_SIZE) {	//配列の末尾にいる場合indexは0へ
		tx_fifo.index_read = 0;
	}
	SCI1.SCR.BIT.TIE = 1;
	SCI1.TDR = data;
}

void TXI1(void) {
	if ((tx_fifo.index_write) != tx_fifo.index_read) {	//未送信データがバッファにある場合
		SCI_put_data_on_TDR();	//データをTDRレジスタに書き込み
	} else {
		SCI1.SCR.BIT.TIE = 0;
	}
}
void SCI_print(unsigned char *str) {
	while (*str != '\0') {
		SCI_single_char_transport_TDR(*str);
		str++;
	}
}
void SCI_println(unsigned char *str) {
	while (*str != '\0') {
		SCI_single_char_transport_TDR(*str);
		str++;
	}
	SCI_single_char_transport_TDR('\r');
	SCI_single_char_transport_TDR('\n');
}
void SCI_val_print(int i) {
	int size = 1;
	int data = i/10;
	while (data>=1){
		data=data/10;
		size++;
	}
	char num[size + 1];
	itoa(i, num, 10);
	num[size]='\0';

	SCI_print(num);
}

void SCI_val_println(int i) {
	SCI_val_print(i);
	SCI_println("");
}
void CMT0_initialize(void) {
	SYSTEM.PRCR.WORD = 0xa50b; /*クロックソース選択の保護の解除*/
	MSTP(CMT0) = 0;             // Wake up CMT0//CMT0の運用開始
	SYSTEM.PRCR.WORD = 0xa500;/*クロックソース選択の保護*/

	CMT.CMSTR0.BIT.STR0 = 0;    // Disable CMT0 count
	CMT0.CMCR.BIT.CMIE = 0;  //CMI0(コンペアマッチ割り込み)禁止

	CMT0.CMCR.BIT.CKS = 3; //8分周
	CMT0.CMCNT = 0;                         //カウンタのリセット
	CMT0.CMCOR = (int) (6250000 / 64 / 2) - 1; //カウントが4999で割り込み 50MHz/8/625 = 10kHz すなはち 100us周期の割り込み

	CMT0.CMCR.BIT.CMIE = 1;                         //CMI0(コンペアマッチ割り込み)許可
	CMT.CMSTR0.BIT.STR0 = 1;    // Enable CMT0 count

	IEN(CMT0,CMI0)= 1;                     //割り込みを許可する
	IPR(CMT0,CMI0)= 6;                     //CMI0の割り込み優先度6を設定(MAX15,MIN1)

}
