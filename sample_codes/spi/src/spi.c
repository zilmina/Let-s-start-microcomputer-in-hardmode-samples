/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  spi                                    */
/*      FILE         :  spi.c                                  */
/*      DESCRIPTION  :  Main Program                           */
/*                                                             */
/*      This file was generated by e2 studio.                  */
/*                                                             */
/***************************************************************/

#include <iodefine.h>
#include <stdint.h>

#include "spi.h"
#ifdef CPPAPP
//Initialize global constructors
extern void __main()
{
  static int initialized;
  if (! initialized)
    {
      typedef void (*pfunc) ();
      extern pfunc __ctors[];
      extern pfunc __ctors_end[];
      pfunc *p;

      initialized = 1;
      for (p = __ctors_end; p > __ctors; )
    (*--p) ();

    }
}
#endif 

int main(void) {
	main_clock_initialize();
		SPI_init();
		SCI_init(115200);
		CMT0_initialize();
    while(1) {

	// TODO: add application code here
    }
return 0;
}

void INT_RSPI0_SPRI0(void) {
	Spi_Receive_Flag = 1;
	PORT1.PODR.BIT.B4 = 0;
}
uint16_t put_SPDR(uint16_t address) {
	Spi_Receive_Flag = 0;
	RSPI0.SPDR.LONG = (uint32_t) address;
	volatile int c = 0;
	while (Spi_Receive_Flag == 0) {
		if (c > 100) {
			break;
		}
		c++;
	}

	// read receive data
	RSPI0.SPDCR.BIT.SPRDTD = 0;
	uint16_t receive = RSPI0.SPDR.LONG; // 受信
	return receive;
}
uint16_t SPI_Encoder_get(void) {

	RSPI0.SPCR.BIT.SPE = 1;
	while (RSPI0.SPCR.BIT.SPE == 0)
		;

//	put_SPDR(0x0000);
//	put_SPDR(0x0000);

	PORTA.PODR.BIT.B4 = 0;   //CS: ENC1
	volatile int i = 0;
	for (i = 0; i < 50; i++) {
	}
	put_SPDR(0x3FFF);

	for (i = 0; i < 50; i++) {
	}
	PORTA.PODR.BIT.B4 = 1;   //CS: ENC1

	for (i = 0; i < 100; i++) {
	}

	PORTA.PODR.BIT.B4 = 0;   //CS: ENC1
	for (i = 0; i < 50; i++) {
	}
	uint16_t receive = put_SPDR(0x0000);
	PORTA.PODR.BIT.B4 = 1;   //CS: ENC1

	for (i = 0; i < 100; i++) {
	}
	PORTA.PODR.BIT.B4 = 1;   //CS: ENC1

	RSPI0.SPCR.BIT.SPE = 0;
	while (RSPI0.SPCR.BIT.SPE == 1)
		;

	return receive & 0x3FFF;
}
void SPI_init(void) {

	PORTC.PDR.BIT.B5 = 1;           //CLK
	PORTC.PDR.BIT.B6 = 1;           //MOSI
	PORTC.PDR.BIT.B7 = 0;           //MISO

	PORTC.PMR.BIT.B5 = 1;           //CLK
	PORTC.PMR.BIT.B6 = 1;           //MOSI
	PORTC.PMR.BIT.B7 = 1;           //MISO

	//mpcの書き込み許可
	MPC.PWPR.BIT.B0WI = 0;          //PFSWEビット書き込み許可
	MPC.PWPR.BIT.PFSWE = 1;         //PFSレジスタへ書き込み許可

	//SPI端子設定
	MPC.PC5PFS.BIT.PSEL = 0x0D;     //RSPCLK
	MPC.PC6PFS.BIT.PSEL = 0x0D;     //MOSI
	MPC.PC7PFS.BIT.PSEL = 0x0D;     //MISO

	MPC.PWPR.BIT.PFSWE = 0;         //PFSレジスタへ書き込み禁止
	MPC.PWPR.BIT.B0WI = 1;          //PFSWEビット書き込み禁止

	PORTA.PDR.BIT.B4 = 1;   //CS: ENC1
//	PORTA.PDR.BIT.B6 = 1;   //CS: ENC2
//	PORTB.PDR.BIT.B0 = 1;   //CS: MPU

// Wake up RSPI0
	SYSTEM.PRCR.WORD = 0xA502;
	MSTP(RSPI0) = 0;
	SYSTEM.PRCR.WORD = 0xA500;

// Stop SPI
	RSPI0.SPCR.BIT.SPE = 0;

// MOSI idle set high
	RSPI0.SPPCR.BIT.MOIFE = 1;
	RSPI0.SPPCR.BIT.MOIFV = 1;

// set for bitrate
	RSPI0.SPBR = 1;

// SPDR is accessed in words
	RSPI0.SPDCR.BIT.SPLW = 1;

	//set sequence
	RSPI0.SPSCR.BIT.SPSLN = 2;
	//set frame
	RSPI0.SPDCR.BIT.SPFC = 0;

	// SPCMD0 setting
	RSPI0.SPCMD0.WORD = 0x0F0D;
	RSPI0.SPCMD1.WORD = 0x0F0D;

	// priority RSPI0 interrupter
	IPR(RSPI0,)= 2;

	// valid receive interrupt controller
	IEN(RSPI0, SPRI0)= 1;
	// valid transmit interrupt controller
	IEN(RSPI0, SPTI0)= 1;

	// permit error interrupter
	RSPI0.SPCR.BIT.SPEIE = 1;
	//ban transmit interrupter
	RSPI0.SPCR.BIT.SPTIE = 0;
	// permit receive interrupter
	RSPI0.SPCR.BIT.SPRIE = 1;
	// set to master mode
	RSPI0.SPCR.BIT.MSTR = 1;

	//dummy read
//	uint16_t dummy = RSPI0.SPCR.BIT.MSTR;

	// valid RSPI Function
//  RSPI0.SPCR.BIT.SPE = 1;
}

void SCI_init(unsigned long bps) {
	int PCLK = 50;

	// Set MPC
	PORT2.PMR.BIT.B6 = 1;           // P26: peripheral
	PORT3.PMR.BIT.B0 = 1;           // P30: peripheral

	MPC.PWPR.BIT.B0WI = 0;          // Release protect
	MPC.PWPR.BIT.PFSWE = 1;
	MPC.P26PFS.BIT.PSEL = 0x0A;     // Set P26: TXD1
	MPC.P30PFS.BIT.PSEL = 0x0A;     // Set P30: RXD1
	MPC.PWPR.BIT.PFSWE = 0;         // Protect
	MPC.PWPR.BIT.B0WI = 1;

	unsigned char smr;
	unsigned char brr;
	int i;

	// RX FIFO
	rx_fifo.index_read = 0;
	rx_fifo.index_write = 0;

	// TX FIFO
	tx_fifo.index_read = 0;
	tx_fifo.index_write = 0;

	// Serial Mode Register
	smr = 0;

	// Bit Rate Register
	brr = (PCLK * 1000 * 1000 / (32 * bps)) - 1;

	SYSTEM.PRCR.WORD = 0xA502;
	MSTP(SCI1) = 0;
	SYSTEM.PRCR.WORD = 0xA500;

	SCI1.SCR.BYTE = 0x00;
	SCI1.SMR.BYTE = smr;
	SCI1.BRR = brr;

	for (i = 0; i < bps + 100; i++)
		;

	IEN(SCI1, TXI1)= 1;
	IEN(SCI1, RXI1)= 1;
	IEN(SCI1, TEI1)= 1;
	//  IEN(SCI1, ERI1)= 1;

	IPR(SCI1,)= 1; //割り込みレベ10

	SCI1.SCR.BIT.RE = 1;	//シリアル受信動作を許可
	SCI1.SCR.BIT.TE = 1;	//シリアル送信動作を許可
	SCI1.SCR.BIT.RIE = 1;	//RXI割り込み（正常にデータが受信でき差にに呼び出される）の許可

}

void SCI_single_char_transport_TDR(unsigned char input_data) {
	tx_fifo.buffer[tx_fifo.index_write] = input_data;	//データを送信バッファに追加
	tx_fifo.index_write++;
	if (tx_fifo.index_write >= BUFFER_SIZE) {	//配列の末尾にいる場合indexは0へ
		tx_fifo.index_write = 0;
	}
	if ((tx_fifo.index_write) != tx_fifo.index_read) {	//未送信データがバッファにある場合
		if (SCI1.SCR.BIT.TIE != 1) {
			SCI_put_data_on_TDR();	//データをTDRレジスタに書き込み
		}
	}

}

void SCI_put_data_on_TDR(void) {
	unsigned char data = tx_fifo.buffer[tx_fifo.index_read];
	tx_fifo.index_read++;

	if ((tx_fifo.index_read) >= BUFFER_SIZE) {	//配列の末尾にいる場合indexは0へ
		tx_fifo.index_read = 0;
	}
	SCI1.SCR.BIT.TIE = 1;
	SCI1.TDR = data;
}

void TXI1(void) {
	if ((tx_fifo.index_write) != tx_fifo.index_read) {	//未送信データがバッファにある場合
		SCI_put_data_on_TDR();	//データをTDRレジスタに書き込み
	} else {
		SCI1.SCR.BIT.TIE = 0;
	}
}
void SCI_print(unsigned char *str) {
	while (*str != '\0') {
		SCI_single_char_transport_TDR(*str);
		str++;
	}
}
void SCI_println(unsigned char *str) {
	while (*str != '\0') {
		SCI_single_char_transport_TDR(*str);
		str++;
	}
	SCI_single_char_transport_TDR('\r');
	SCI_single_char_transport_TDR('\n');
}
void SCI_val_print(int i) {
	int size = 1;
	int data = i/10;
	while (data>=1){
		data=data/10;
		size++;
	}
	char num[size + 1];
	itoa(i, num, 10);
	num[size]='\0';

	SCI_print(num);
}

void SCI_val_println(int i) {
	SCI_val_print(i);
	SCI_println("");
}
void main_clock_initialize(void) {

	//PLL(Phase Locked Loop:発振器からの周波数を逓倍)の動作周波数はMAX:200MHz
	//動作周期は100MHz
	/* PLL回路 20逓倍× 入力1分周 (10.000MHz * 20 = 200MHz)
	 * 0b00 010011 000000 00 = 0x1300*/
	SYSTEM.PRCR.WORD = 0xa501; /*クロックソース選択の保護の解除*/
	SYSTEM.PLLCR.WORD = 0x1300;
	SYSTEM.PLLCR2.BIT.PLLEN = 0; /*PLL ENABLE */

	/* BCLK端子出力1/4(MAX:50MHz)(BCLKとBCLK端子出力は別)0010b
	 * PCLKB1/4(MAX:50MHz)0010b
	 * PCLKA=ICLK1/2(MAX:100MHz)0001b
	 * SDCLK停止 1
	 * BCLK停止 1
	 * ICK1/2(MAX:100MHz) 0001b
	 * FCK1/4(MAX:50MHz) 0010b
	 * 0b 0010 0001 1 1 00 0001 0010 0010 0001 0001 = 0x21C12211 */
	SYSTEM.SCKCR.LONG = 0x21C12211;

	/* IEBCK1/4(MAX:50MHz)0010b
	 * UCLK1/4(使わない場合0001b)
	 * 00000000 0001 0010b = 0x0012  */
	SYSTEM.SCKCR2.WORD = 0x0012;

	/*BCLK = (1/2) * PLL(MAX:100MHz) */
	SYSTEM.BCKCR.BYTE = 0x01;

	/* クロックソース選択：PLL回路選択100
	 * 00000 100 00000000b = 0x0400*/
	SYSTEM.SCKCR3.WORD = 0x0400;

	SYSTEM.PRCR.WORD = 0xa500; /*クロックソース選択の保護*/
}
void CMT0_initialize(void) {
	SYSTEM.PRCR.WORD = 0xa50b; /*クロックソース選択の保護の解除*/
	MSTP(CMT0) = 0;             // Wake up CMT0//CMT0の運用開始
	SYSTEM.PRCR.WORD = 0xa500;/*クロックソース選択の保護*/

	CMT.CMSTR0.BIT.STR0 = 0;    // Disable CMT0 count
	CMT0.CMCR.BIT.CMIE = 0;  //CMI0(コンペアマッチ割り込み)禁止

	CMT0.CMCR.BIT.CKS = 3; //8分周
	CMT0.CMCNT = 0;                         //カウンタのリセット
	CMT0.CMCOR = (int) (6250000 / 64 / 2) - 1; //カウントが4999で割り込み 50MHz/8/625 = 10kHz すなはち 100us周期の割り込み

	CMT0.CMCR.BIT.CMIE = 1;                         //CMI0(コンペアマッチ割り込み)許可
	CMT.CMSTR0.BIT.STR0 = 1;    // Enable CMT0 count

	IEN(CMT0,CMI0)= 1;                     //割り込みを許可する
	IPR(CMT0,CMI0)= 6;                     //CMI0の割り込み優先度6を設定(MAX15,MIN1)

//    runtime_raw = 0;
}
